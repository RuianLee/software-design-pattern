# 需求逐句分析 - 類別圖無法表達的內容標記

> 🔴 = 類別圖無法表達的內容
> 🟢 = 可以在類別圖中表達的內容

---

## 詞彙表部分

### 第4行
```
Big-2：大老二撲克牌遊戲，正是我們想要你開發的遊戲。
```
- 🟢 **Big-2**（類別名稱候選）
- 🟢 **遊戲**（類別名稱候選：Game）

---

### 第5行
```
玩家 (Player)：遊戲的參與者，可能為 AI 或是人類玩家 (Human Player)。
```
- 🟢 **玩家 (Player)**（類別名稱）
- 🟢 **AI**（子類別候選）
- 🟢 **人類玩家 (Human Player)**（子類別候選）
- 🔴 **可能為**（條件判斷，屬於多型的運行時行為）

---

### 第6行
```
撲克牌 (Card)： 為 (數字、花色) 的組合。
```
- 🟢 **撲克牌 (Card)**（類別名稱）
- 🟢 **數字**（屬性：Rank）
- 🟢 **花色**（屬性：Suit）
- 🟢 **組合**（組合關係：Card 包含 Rank 和 Suit）

---

### 第7行
```
數字 (Rank)： 撲克牌上的數字，為 {3,4,5,6,7,8,9,10,J,Q,K,A,2} 中其中一項。
```
- 🟢 **數字 (Rank)**（列舉型別或類別）
- 🟢 **{3,4,5,6,7,8,9,10,J,Q,K,A,2}**（列舉值）
- 🔴 **中其中一項**（值域約束，屬於驗證邏輯）

---

### 第8-9行
```
花色 (Suit)： 撲克牌上的花色，為
{梅花(♣),菱形(♦),愛心(♥),黑桃(♠)} 中其中一項。
```
- 🟢 **花色 (Suit)**（列舉型別或類別）
- 🟢 **{梅花,菱形,愛心,黑桃}**（列舉值）
- 🔴 **中其中一項**（值域約束）

---

### 第10行
```
牌堆 (Deck)： 一副 52 張不同撲克牌的牌堆。
```
- 🟢 **牌堆 (Deck)**（類別名稱）
- 🟢 **撲克牌**（關聯：Deck 包含多張 Card）
- 🔴 **52 張**（數量約束，屬於初始化邏輯）
- 🔴 **不同**（唯一性約束，屬於驗證邏輯）

---

### 第11行
```
發牌 (Deal)： 玩家從牌堆中的頂部取走一張牌。
```
- 🟢 **發牌 (Deal)**（方法名稱：deal()）
- 🟢 **玩家**（方法調用者或參數）
- 🟢 **牌堆**（方法涉及的物件）
- 🔴 **從...頂部取走**（方法內部實作邏輯：deck.pop()）
- 🔴 **一張牌**（回傳值數量）

---

### 第12行
```
手牌 (Hand cards)： 玩家擁有的手牌，最少 0 張，最多 13 張。
```
- 🟢 **手牌 (Hand cards)**（屬性：List<Card>）
- 🟢 **玩家擁有的**（關聯關係：Player 擁有 Hand）
- 🔴 **最少 0 張，最多 13 張**（數量約束，屬於驗證邏輯）

---

### 第13行
```
牌型 (Card Pattern)： 撲克牌的組合。
```
- 🟢 **牌型 (Card Pattern)**（需求術語，指稱 Single/Pair/Straight/FullHouse 等類別）
- 🟢 **撲克牌的組合**（關聯：這些牌型類別包含多張 Card）

---

### 第14行
```
打牌 (Play)： 玩家從手牌中打出合法牌型至檯面上的動作。
```
- 🟢 **打牌 (Play)**（方法名稱：play()）
- 🟢 **玩家**（方法調用者）
- 🟢 **手牌**（方法涉及的物件）
- 🟢 **牌型**（方法的參數或回傳值）
- 🟢 **檯面**（類別候選：Table）
- 🔴 **從...打出...至...**（方法內部的資料流動）
- 🔴 **合法**（前置驗證邏輯：if (!isValid()) return false）

---

### 第15行
```
回合 (Round)： 遊戲會有多個回合，在每回合之中，四位玩家輪流打牌，直到有三位玩家連續喊出了 PASS。
```
- 🟢 **回合 (Round)**（類別名稱候選）
- 🟢 **遊戲**（關聯：Game 包含多個 Round）
- 🟢 **玩家**（參與者）
- 🟢 **打牌**（方法）
- 🟢 **PASS**（動作類型或列舉值）
- 🔴 **會有多個**（物件數量的動態性）
- 🔴 **在每回合之中**（作用域/生命週期）
- 🔴 **四位玩家輪流**（迴圈邏輯：for (i=0; i<4; i++)）
- 🔴 **直到有三位玩家連續喊出了**（迴圈終止條件：while (consecutivePasses < 3)）

---

### 第16行
```
頂牌 Top play： 檯面上目前最大的牌型。
```
- 🟢 **頂牌 (Top play)**（屬性：topPlay）
- 🟢 **檯面**（屬性的擁有者）
- 🟢 **牌型**（屬性的型別）
- 🔴 **目前**（狀態的時變性）
- 🔴 **最大的**（比較結果，屬於演算法產生的狀態）

---

### 第17行
```
頂牌玩家 Top player： 打出頂牌的玩家。
```
- 🟢 **頂牌玩家 (Top player)**（屬性：topPlayer）
- 🟢 **玩家**（屬性型別）
- 🔴 **打出頂牌的**（因果關係，屬於狀態轉換邏輯）

---

## 遊戲流程部分

### 第19行
```
遊戲依序遵照以下流程進行：
```
- 🟢 **遊戲**（主控類別：Game）
- 🟢 **流程**（方法候選：start(), run()）
- 🔴 **依序遵照**（方法調用順序）
- 🔴 **進行**（循序執行的過程）

---

### 第21-23行
```
遊戲中有四位玩家。遊戲開始之後就會輸入每個玩家的名稱 (Name)。在這份需求中，我們會使用數字
{0,1,2,3} 來索引這四位玩家。並且，假設目前輪到了玩家i，則「下一輪的玩家」為索引值
(i+1)%4 的玩家。
```
- 🟢 **玩家**（類別）
- 🟢 **名稱 (Name)**（屬性：String name）
- 🟢 **索引**（屬性：int index 或使用陣列/List）
- 🔴 **四位**（數量約束）
- 🔴 **遊戲開始之後就會輸入**（時序：start() → inputNames()）
- 🔴 **使用數字 {0,1,2,3} 來索引**（資料結構實作細節：陣列或List）
- 🔴 **假設目前輪到了**（運行時狀態）
- 🔴 **下一輪的玩家**（狀態轉換）
- 🔴 **(i+1)%4**（演算法細節：計算下一位玩家的公式）

---

### 第24行
```
將牌堆洗牌，並且將 52 張牌輪流發給四位玩家直到牌堆空 (Empty) 了為止。
```
- 🟢 **牌堆**（物件：Deck）
- 🟢 **洗牌**（方法：shuffle()）
- 🟢 **發給**（方法：deal()）
- 🟢 **玩家**（方法參數）
- 🟢 **空 (Empty)**（狀態判斷方法：isEmpty()）
- 🔴 **將...洗牌，並且將...發給**（方法調用順序：shuffle() → deal()）
- 🔴 **52 張牌**（初始化數量）
- 🔴 **輪流發給**（迴圈：for each player）
- 🔴 **直到牌堆空了為止**（迴圈終止條件：while (!deck.isEmpty())）

---

### 第25-26行
```
接著開始遊戲的第一回合：
在第一回合中，由擁有梅花3的玩家首先出牌。此玩家必須打出一副合法且包含梅花3的牌型。打出來的牌型便成為目前的頂牌。
```
- 🟢 **回合**（物件：Round）
- 🟢 **玩家**（物件）
- 🟢 **梅花3**（特定牌：Card(CLUB, THREE)）
- 🟢 **出牌**（方法：play()）
- 🟢 **牌型**（物件：Single/Pair/Straight/FullHouse 其中之一）
- 🟢 **頂牌**（屬性：topPlay）
- 🔴 **接著開始**（時序：deal() → startFirstRound()）
- 🔴 **第一回合**（狀態標記：isFirstRound）
- 🔴 **由擁有梅花3的玩家**（條件判斷：if (player.hasCard(CLUB_3))）
- 🔴 **首先**（執行順序）
- 🔴 **必須打出**（強制性約束，屬於驗證邏輯）
- 🔴 **合法且包含梅花3的**（複合條件：if (isValid() && contains(CLUB_3))）
- 🔴 **打出來的牌型便成為目前的頂牌**（狀態轉換：topPlay = playedPattern）

---

### 第27-29行
```
然後，下一輪的玩家可以決定要執行以下其一動作：
喊 PASS —— 放棄出牌機會，不打任何牌。
打出一副比頂牌還大的合法牌型。此新打出來的牌型便成為新的頂牌。
```
- 🟢 **玩家**（物件）
- 🟢 **動作**（列舉或抽象類別：Action）
- 🟢 **PASS**（動作類型：PassAction）
- 🟢 **打出**（方法：play()）
- 🟢 **頂牌**（屬性）
- 🟢 **牌型**（物件：Single/Pair/Straight/FullHouse 其中之一）
- 🔴 **然後**（時序詞）
- 🔴 **下一輪的玩家**（狀態轉換：currentPlayer = nextPlayer()）
- 🔴 **可以決定**（條件分支）
- 🔴 **執行以下其一**（if-else 邏輯）
- 🔴 **放棄出牌機會，不打任何牌**（PASS 動作的語意說明，屬於註解）
- 🔴 **比頂牌還大的**（比較邏輯：if (newPattern.compareTo(topPlay) > 0)）
- 🔴 **合法**（驗證邏輯：if (!isValid()) return false）
- 🔴 **此新打出來的牌型便成為新的頂牌**（狀態轉換：topPlay = newPattern）

---

### 第30行
```
下一輪的玩家重複步驟 b，直到玩家們連續喊出了三個PASS。
```
- 🟢 **玩家**（物件）
- 🟢 **PASS**（動作）
- 🔴 **下一輪的玩家**（狀態轉換：currentPlayer = nextPlayer()）
- 🔴 **重複步驟 b**（迴圈：while (true) { ... }）
- 🔴 **直到玩家們連續喊出了三個PASS**（迴圈終止條件：if (consecutivePasses == 3) break）

---

### 第31-34行
```
第一回合結束後，開始下一回合。之後的每一回合都和第一回合有著相同的步驟和規則，不過多了以下規則：
每一回合結束之後，檯面上的牌會被清空，意即，清空頂牌。
上一回合的頂牌玩家將會成為新的回合的頂牌玩家，並且新的回合由頂牌玩家開始打牌，並且不能喊 PASS。舉例來說，如果上一回合結束時的頂牌玩家為玩家
i，則在新的一回合時時，由玩家i開始打牌。
```
- 🟢 **回合**（物件）
- 🟢 **頂牌玩家**（屬性）
- 🟢 **檯面**（物件：Table）
- 🟢 **頂牌**（屬性）
- 🟢 **玩家**（物件）
- 🟢 **打牌**（方法）
- 🟢 **PASS**（動作）
- 🔴 **第一回合結束後**（時序與狀態轉換）
- 🔴 **開始下一回合**（方法調用：startNextRound()）
- 🔴 **之後的每一回合**（迴圈：while (!gameOver)）
- 🔴 **和第一回合有著相同的步驟**（流程復用）
- 🔴 **不過多了以下規則**（條件分支：if (!isFirstRound)）
- 🔴 **每一回合結束之後**（生命週期事件）
- 🔴 **會被清空**（狀態重置：table.clear(), topPlay = null）
- 🔴 **上一回合的頂牌玩家將會成為新的回合的頂牌玩家**（狀態保留與傳遞）
- 🔴 **新的回合由頂牌玩家開始**（起始條件：currentPlayer = topPlayer）
- 🔴 **不能喊 PASS**（約束邏輯：if (action == PASS) return error）
- 🔴 **如果...則...**（條件判斷）

---

### 第35行
```
不斷地進入下一回合、下一輪，直到有任一玩家將所有的手牌打完為止，此時遊戲將立刻結束，並且宣告此玩家為遊戲的贏家 (Winner)。
```
- 🟢 **回合**（物件）
- 🟢 **玩家**（物件）
- 🟢 **手牌**（屬性）
- 🟢 **遊戲**（物件）
- 🟢 **贏家 (Winner)**（屬性：Player winner）
- 🔴 **不斷地進入**（主迴圈：while (true)）
- 🔴 **下一回合、下一輪**（狀態轉換）
- 🔴 **直到有任一玩家將所有的手牌打完為止**（迴圈終止條件：if (player.getHandCards().isEmpty())）
- 🔴 **此時**（時間點）
- 🔴 **立刻結束**（程式流程控制：return）
- 🔴 **宣告此玩家為贏家**（狀態轉換：winner = player）

---

## 牌型與大小比較部分

### 第37行
```
初版的需求中一共有以下四種牌型。只有相同種類的牌型之間可以比較大小。
```
- 🟢 **牌型**（需求術語，描述撲克牌組合的概念）
- 🟢 **四種牌型**（四個獨立類別：Single, Pair, Straight, FullHouse）
- 🟢 **比較大小**（每個類別各自的方法）
- 🔴 **一共有以下四種**（類別數量，屬於設計決策）
- 🔴 **只有相同種類的牌型之間可以比較**（前置條件驗證邏輯）

---

### 第39-44行
```
單張 (Single)：一張牌。
大小比較規則：先比數字再比花色。
數字由小到大依序為：

3<4<5<...<10<J<Q<K<A<2
花色由小到大依序為：梅花 < 菱形 < 愛心 < 黑桃
```
- 🟢 **單張 (Single)**（類別名稱）
- 🟢 **牌**（屬性：Card）
- 🟢 **數字**（Rank）
- 🟢 **花色**（Suit）
- 🟢 **比較規則**（方法：compareTo()）
- 🔴 **一張牌**（屬性數量約束）
- 🔴 **先比數字再比花色**（方法內部邏輯：先 rank.compareTo() 再 suit.compareTo()）
- 🔴 **數字由小到大依序為：3<4<5<...<10<J<Q<K<A<2**（演算法細節，Rank 列舉的排序邏輯）
- 🔴 **花色由小到大依序為：梅花 < 菱形 < 愛心 < 黑桃**（演算法細節，Suit 列舉的排序邏輯）

---

### 第45-46行
```
對子 (Pair)：兩張數字相同的牌；例如：J-J、3-3。
大小比較規則：將兩張牌中較大的牌作為比較基準；例如：A-A > 7-7
```
- 🟢 **對子 (Pair)**（類別名稱）
- 🟢 **牌**（屬性：List<Card>）
- 🟢 **數字**（用於驗證）
- 🟢 **比較規則**（方法：compareTo()）
- 🔴 **兩張**（數量約束：if (cards.size() != 2) return false）
- 🔴 **數字相同的**（驗證邏輯：if (card1.getRank() != card2.getRank()) return false）
- 🔴 **將兩張牌中較大的牌作為比較基準**（演算法細節：Math.max(card1, card2).compareTo(...)）

---

### 第47-48行
```
順子 (Straight)： 任何連續數字的五張牌；例如：3-4-5-6-7、10-J-Q-K-A、J-Q-K-A-2，或是 K-A-2-3-4。
大小比較規則：將五張牌中最大的牌作為比較基準；例如：2-3-4-5-6 > 10-J-Q-K-A
```
- 🟢 **順子 (Straight)**（類別名稱）
- 🟢 **牌**（屬性：List<Card>）
- 🟢 **數字**（用於驗證）
- 🟢 **比較規則**（方法：compareTo()）
- 🔴 **五張牌**（數量約束）
- 🔴 **任何連續數字的**（驗證邏輯，需要檢查是否連續）
- 🔴 **例如：K-A-2-3-4**（特殊順子，繞圈的演算法邏輯）
- 🔴 **將五張牌中最大的牌作為比較基準**（演算法細節：Collections.max(cards).compareTo(...)）

---

### 第49-50行
```
葫蘆 (Full house)： 五張牌，其中以兩部分構成——三張數字相同的牌，和兩張數字相同的牌；例如： 3-3-3-2-2、A-A-A-7-7。
大小比較規則：以三張數字相同的牌中，數字最大的牌作為比較基準；例如：A-A-A-3-3 > 5-5-5-2-2。
```
- 🟢 **葫蘆 (Full house)**（類別名稱）
- 🟢 **牌**（屬性：List<Card>）
- 🟢 **比較規則**（方法：compareTo()）
- 🔴 **五張牌**（數量約束）
- 🔴 **以兩部分構成**（結構驗證邏輯）
- 🔴 **三張數字相同的牌**（驗證邏輯：找出三條）
- 🔴 **兩張數字相同的牌**（驗證邏輯：找出對子）
- 🔴 **以三張數字相同的牌中，數字最大的牌作為比較基準**（演算法細節：找出三條後取其中一張比較）

---

## 總結：類別圖無法表達的關鍵字模式

### 🔴 時序類
- 接著、然後、之後、開始、結束、首先
- 依序、輪流、重複、不斷地
- 上一回合、下一回合、目前、此時

### 🔴 條件類
- 如果、則、假設
- 可以決定、必須、不能
- 只有...才能、以下其一

### 🔴 迴圈類
- 直到...為止
- 輪流...直到...
- 不斷地...直到...
- 連續

### 🔴 狀態轉換類
- 便成為、將會成為
- 被清空、打完
- 立刻結束

### 🔴 演算法類
- 先...再...
- 由小到大、由大到小
- 較大的、最大的
- 作為比較基準
- (i+1)%4 等數學公式

### 🔴 數量約束類
- 一張、兩張、五張、52張
- 最少、最多
- 連續數字

### 🔴 驗證邏輯類
- 合法
- 相同的
- 包含
- 不同
